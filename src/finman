#!/usr/bin/env python3

import argparse
import logging as log
import os
import sys
from typing import Optional

from finmanlib.data_transactions_file import TransactionsFile
from finmanlib.edit import TransactionsEdit
from finmanlib.error import FinmanError, Error



class Parser:
    """
        Parse both command-line arguments and interactive commands.

        Front-end methods:
        * parse_cmdline()
        * parse_input()
        * apply_aliases()
    """

    # Default aliases for interactive mode.
    aliases = {
        "?": "-h",
        "w": "write --confirm",
        "W": "write",
        "q": "quit --only-if-unchanged",
        "Q": "quit", 

        "p": "print --fields ~ --filter $1",
        "P": "print --fields ~ --filter cat= --nostore",

        # TBD: Update aliases!!
        "c": "set categories --fields ~ --indices $1",
        "r": "set remarks --fields ~ --indices $1",

        "o": "options",
        "o $1 $2" : "options $1 $2"
    }


    def __init__(self):
        """
            Prepare the two parser objects for later use.
        """
        self.parser_cmdline = self._get_parser(True)
        self.parser_interactive = self._get_parser(False)


    def parse_cmdline(self) -> argparse.Namespace:
        """
            Parse command-line arguments in sys.argv.
        """
        return self.parser_cmdline.parse_args()


    def parse_input(self, inp: str) -> argparse.Namespace:
        """
            Parse command given as string.
        """

        # Parse arguments.
        try:
            # TBD: respect quotes in slitting
            # re.findall(r'(?:[^\s,"]|"(?:\\.|[^"])*")+', s)
            # https://stackoverflow.com/questions/16710076
            return self.parser_interactive.parse_args(inp.split())

        except SystemExit:
            # In case of "-h" or invalid commands.
            # Info/error message was already printed.
            return None


    def apply_aliases(self, inp: str) -> Optional[str]:
        """
            Apply aliases on given command string.

            Return value:
            - None, if number of argument mismatches alias definition.
            - str containing expanded command, if alias matches.
            - str containing original command, if alias does not match.
        """
        inp_cmd, *inp_args = inp.split()
        for alias_cmd, resolution in self.aliases.items():
            resolution_cmd, *resolution_args = resolution.split()
            if inp_cmd == alias_cmd:
                
                # Determine number of distinct placeholders for alias.
                num_placeholders = 0
                for arg in resolution_args:
                    if len(arg) == 2 and arg[0] == '$' and '1' <= arg[1] <= '9':
                        num_placeholders = max(num_placeholders, int(arg[1]))

                # In case of incorrect number of arguments, give None.
                if len(inp_args) != num_placeholders:
                    return None

                # Otherwise, replace placeholders with arguments.
                for idx, arg in enumerate(inp_args, 1):
                    resolution = resolution.replace(f'${idx}', arg)
                if True:    # TBD: debug
                    print(f"> {resolution}")
                return resolution

        # No alias matched; return unmodified input.
        return inp


    def _get_parser(self, cmdline_parser: bool) -> argparse.ArgumentParser:
        """
            Return a parser object, either for command-line arguments
            or for interactive commands.
        """

        # TBD: in case of not get_cmd_line_parser: remove sys.argv[0].
        parser_toplevel = argparse.ArgumentParser(
                prog = None if cmdline_parser else "",
                description = "Manage finance files",
                formatter_class = argparse.RawDescriptionHelpFormatter)
        if cmdline_parser:
            parser_toplevel.add_argument(
                    'json_file',
                    metavar = 'JSON',
                    help = "name of Finman JSON transactions file")
        subparsers_cmd = parser_toplevel.add_subparsers(
                dest = 'cmd',
               #metavar = 'CMD',
                help = "command to execute")

        # Particular options for command-line parser.
        if cmdline_parser:

            # Subparser for subcommand 'new'.
            parser_new = subparsers_cmd.add_parser(
                    'new',
                    help = "create a new Finman file")

        # Subparser for subcommand 'import'.
        parser_import = subparsers_cmd.add_parser(
                'import_data',
                help = "import data into a Finman file")
        subparsers_import = parser_import.add_subparsers(
                dest = 'kind',
                help = "which kind of file to import")
        parser_import_cat = subparsers_import.add_parser(
                'categories',
                help = "import categories")
        parser_import_cat.add_argument(
                'filename',
                metavar = 'JSON',
                help = "JSON file containing categories")
        parser_import_csv_format = subparsers_import.add_parser(
                'csv-format',
                help = "import a CSV format")
        parser_import_csv_format.add_argument(
                'filename',
                metavar = 'JSON',
                help = "JSON file containing the CSV format")
        parser_import_csv = subparsers_import.add_parser(
                'csv',
                help = "import transactions from a CSV file")
        parser_import_csv.add_argument(
                'filename',
                metavar = 'CSV',
                help = "CSV file containing the transactions")
        parser_import_csv.add_argument(
                'csv_format_name',
                metavar = 'CSV_FMT',
                help = "format to use for evaluation of CSV file")

        # Subparser for subcommand 'info'.
        parser_info = subparsers_cmd.add_parser(
                'info',
                help = "print various information of Finman file")
        subparsers_info = parser_info.add_subparsers(
                dest = 'subcmd',
                help = "which information to print")
        parser_info_file = subparsers_info.add_parser(
                'file',
                help = "print information of about Finman file")
        parser_info_cats = subparsers_info.add_parser(
                'cats',
                help = "print categories provided in Finman file")
        parser_info_used_cats = subparsers_info.add_parser(
                'used-cats',
                help = "print categories actually used in Finman file")
        parser_info_file = subparsers_info.add_parser(
                'options',
                help = "print options of current Finman session")

        # Subparser for subcommand 'print'.
        parser_print = subparsers_cmd.add_parser(
                'print',
                help = "print information from a Finman file")
        parser_print.add_argument(
                '--fields',
                metavar = 'FIELDS',
                default = None,
                dest = 'fields_str',
                help = "(possibly abbreviated) fields (separated by '|'); empty string = default columns")
        parser_print.add_argument(
                '--filter',
                metavar = 'FILTER',
                default = None,
                dest = 'filter_str',
                help = "filter rules (separated by '|')")
        parser_print.add_argument(
                '--sort',
                metavar = 'SORT',
                default = None,
                dest = 'sort_str',
                help = "fields by which to sort")
        parser_print.add_argument(
                '--indices',
                metavar = 'INDICES',
                default = '*',
                dest = 'indices_str',
                help = "indices of entries to print")
        parser_print.add_argument(
                '--ids',
                metavar = 'IDs',
                default = '',
                dest = 'ids',
                help = "transaction IDs")
        parser_print.add_argument(
                '--nostore',
                action = 'store_false',
                dest = 'store',
                help = "do not remember output as new filtered results (not relevant for batch mode)")
        parser_print.add_argument(
                '--not-numbered',
                action = 'store_false',
                dest = 'numbered',
                help = "do not give line numbers in output")
        parser_print.add_argument(
                '--csv',
                action = 'store_true',
                help = "print in CSV format instead of formatted table")
        parser_print.add_argument(
                '--export',
                metavar = 'FILE',
                default = None,
                dest = 'export_filename',
                help = "do not print to screen but to this file")

        # Subparser for subcommand 'set'.
        parser_set = subparsers_cmd.add_parser(
                'set',
                help = "set categories and remarks in transactions")
        parser_set.add_argument(
                '--fields',
                metavar = 'FIELDS',
                default = None,
                dest = 'fields_str',
                help = "(possibly abbreviated) fields (separated by '|'); empty string = default columns")
        parser_set.add_argument(
                '--filter',
                metavar = 'FILTER',
                default = None,
                dest = 'filter_str',
                help = "filter rules (separated by '|')")
        parser_set.add_argument(
                '--sort',
                metavar = 'SORT',
                default = None,
                dest = 'sort_str',
                help = "fields by which to sort")
        parser_set.add_argument(
                '--indices',
                metavar = 'INDICES',
                default = '*',
                dest = 'indices_str',
                help = "indices of entries")
        parser_set.add_argument(
                '--ids',
                metavar = 'IDs',
                default = '',
                dest = 'ids',
                help = "transaction IDs")
        parser_set.add_argument(
                '--nostore',
                action = 'store_false',
                dest = 'store',
                help = "do not remember output as new filtered results (not relevant for batch mode)")
        parser_set.add_argument(
                '--value',
                dest = 'value',
                metavar = 'VALUE',
                default = None,
                help = "new remark/category value")
        parser_set.add_argument(
                dest = 'kind',
                choices = ['remarks', 'categories'],
                help = "which transaction fields to set")

#       parser_set_remark = subparsers_set.add_parser(
#               'remark',
#               help = "set remarks of specific transactions")

#       parser_set_cats = subparsers_set.add_parser(
#               'cats',
#               help = "set category of specific transactions")
#       parser_set_cats.add_argument(
#               '--fields',
#               metavar = 'FIELDS',
#               default = None,
#               dest = 'fields_str',
#               help = "(possibly abbreviated) fields (separated by '|'); empty string = default columns")
#       parser_set_cats.add_argument(
#               '--filter',
#               metavar = 'FILTER',
#               default = None,
#               dest = 'filter_str',
#               help = "filter rules (separated by '|')")
#       parser_set_cats.add_argument(
#               '--sort',
#               metavar = 'SORT',
#               default = None,
#               dest = 'sort_str',
#               help = "fields by which to sort")
#       parser_set_cats.add_argument(
#               '--indices',
#               metavar = 'INDICES',
#               default = '*',
#               dest = 'indices_str',
#               help = "indices of entries to print")
#       parser_set_cats.add_argument(
#               '--nostore',
#               action = 'store_false',
#               dest = 'store',
#               help = "do not remember output as new filtered results (not relevant for batch mode)")

#       parser_set_cats_auto = subparsers_set.add_parser(
#               'cats-auto',
#               help = "apply category rules on all transactions")
        # TBD

        # Options only present for command-line parser.
        if cmdline_parser:

            # Subparser for subcommand 'edit'.
            parser_edit = subparsers_cmd.add_parser(
                    'edit',
                    help = "interactively view/edit Finman file")
            parser_edit.add_argument(
                    '--fields',
                    dest = 'fields_str',
                    help = "default fields to be displayed")

        # Options only present for interactive-command parser.
        else:
            # Subparser for subcommand 'write'.
            parser_write = subparsers_cmd.add_parser(
                    'write',
                    help = "write Finman file")
            parser_write.add_argument(
                    '--confirm',
                    action = 'store_true',
                    help = "ask whether to write file")

            # Subparser for subcommand 'quit'.
            parser_quit = subparsers_cmd.add_parser(
                    'quit',
                    help = "quit interactive prompt")
            parser_quit.add_argument(
                    '--only-if-unchanged',
                    action = 'store_true',
                    help = "ask whether to write file")

            parser_toplevel.epilog = "Aliases:\n" + "\n".join(
                    "    %-10s  %s" % al for al in self.aliases.items())

            # TBD: add new command 'alias', to define custom aliases!

        return parser_toplevel


def run_cmd(edit, args: argparse.Namespace):
    """
        Run the command in the given args, by calling the respective function of
        the 'edit' object with the given arguments.
    """
    if True:    # TBD: debug
        print("> Args:")
        for key, value in vars(args).items():
            print(f"    {key} = {repr(value)}")
    func = getattr(edit, args.cmd)
    values = vars(args)
    del values['cmd']
    try:
        del values['json_file']
    except KeyError:
        pass
    func(**values)


def main():
    """
        Main program, which performs either a single command or enters the
        interactive command loop.
    """
    log.basicConfig(level = log.INFO, format = "%(message)s")

    # Evaluate command line.
    parser = Parser()
    args = parser.parse_cmdline()

    # Prepare processing.
    trns_file = TransactionsFile(args.json_file)
    if args.cmd == 'new':
        # It's easier to handle the special case 'new' here, than implement it
        # in class TransactionsEdit.
        trns_file.save()
        return

    trns_file.load()
    edit = TransactionsEdit(trns_file)

    # Process the given command...
    if args.cmd != 'edit':
        run_cmd(edit, args)


    # ... or begin interactive command loop, if requested.
    else:
        edit.interactive = True

        while not edit.stop_loop:
            print()

            # Get command input.
            try:
                inp = input("\nfinman> ")
            except KeyboardInterrupt:
                continue
            except EOFError: # Ctrl-D
                inp = 'q'
                print()

            # Ignore empty input and comments.
            inp = inp.strip()
            if inp == '':
                print("Enter '?' for help.")
                continue
            if inp[0] == '#':
                continue

            # Apply aliases and parse command input.
            inp = parser.apply_aliases(inp)
            if inp is None:
                print("Bad number of arguments for alias.")
                continue
            args = parser.parse_input(inp)

            # If command could not be parsed, give error message.
            if args is None:
                if '-h' not in inp.split():
                    print()
                    print("Enter '?' for help.")
                continue

            # Process command input.
            try:
                run_cmd(edit, args)
            except FinmanError as e:
                log.error(f"Error: {e}")


#       elif args.cmd == 'import':
#           tfile = TransactionsFileOps(args.json_file)
#           tfile.load()
#           tfile.import_csv(args.csv_file, args.csv_format)
#           tfile.save()

#       elif args.cmd == 'cat':
#           tfile = TransactionsFileOps(args.json_file)
#           tfile.load()
#           assignments = tfile.evaluate_category_filters()
#           transactions_map = {t.id: t for t in tfile.transactions}
#           for t_id, cat_str in assignments:
#               transactions_map[t_id].category = cat_str
#               transactions_map[t_id].category_automatically_set = "yes"
#           tfile.save()


if __name__ == "__main__":
    try:
        main()

    except FinmanError as e:
        log.error(f"Error: {e}")
        sys.exit(1)
